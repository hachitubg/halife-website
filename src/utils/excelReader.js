// src/utils/excelReader.js
// Utility ƒë·ªÉ ƒë·ªçc file Excel v√† convert sang format ph√π h·ª£p cho Vue app

import * as XLSX from 'xlsx';

class ExcelReader {
  constructor() {
    this.products = [];
    this.categories = [];
    this.lastUpdated = null;
    this.isLoaded = false;
    this.error = null;
  }

  /**
   * ƒê·ªçc file Excel t·ª´ ƒë∆∞·ªùng d·∫´n
   * @param {string} filePath - ƒê∆∞·ªùng d·∫´n file Excel
   * @returns {Promise<Object>} - Promise ch·ª©a data ƒë√£ ƒë∆∞·ª£c parse
   */
  async readExcelFile(filePath) {
    try {
      console.log('üìñ ƒêang ƒë·ªçc file Excel t·ª´:', filePath);
      
      // Fetch file t·ª´ public directory
      const response = await fetch(filePath);
      
      if (!response.ok) {
        throw new Error(`Kh√¥ng th·ªÉ t·∫£i file: ${response.status} ${response.statusText}`);
      }
      
      const arrayBuffer = await response.arrayBuffer();
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });

      // Parse c√°c sheet
      const result = {
        products: this.parseProductsSheet(workbook),
        categories: this.parseCategoriesSheet(workbook),
        metadata: this.parseMetadata(workbook)
      };

      // Cache data
      this.products = result.products;
      this.categories = result.categories;
      this.lastUpdated = new Date();
      this.isLoaded = true;
      this.error = null;

      console.log('‚úÖ Excel file ƒë√£ ƒë∆∞·ª£c ƒë·ªçc th√†nh c√¥ng');
      console.log(`üìä ${result.products.length} s·∫£n ph·∫©m v√† ${result.categories.length} danh m·ª•c`);

      return result;
      
    } catch (error) {
      console.error('‚ùå L·ªói ƒë·ªçc file Excel:', error);
      this.error = error.message;
      this.isLoaded = false;
      throw error;
    }
  }

  /**
   * Parse sheet Products
   * @param {Object} workbook - XLSX workbook object
   * @returns {Array} - M·∫£ng s·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c format
   */
  parseProductsSheet(workbook) {
    const sheetName = 'Products';
    const worksheet = workbook.Sheets[sheetName];
    
    if (!worksheet) {
      throw new Error(`Sheet "${sheetName}" kh√¥ng t·ªìn t·∫°i`);
    }

    // Convert sheet th√†nh JSON
    const rawData = XLSX.utils.sheet_to_json(worksheet, { 
      defval: "",
      raw: false // Gi·ªØ nguy√™n format text
    });

    if (rawData.length === 0) {
      throw new Error('Sheet Products kh√¥ng c√≥ d·ªØ li·ªáu');
    }

    console.log('üìã ƒê√£ ƒë·ªçc', rawData.length, 'd√≤ng d·ªØ li·ªáu t·ª´ sheet Products');

    return rawData
      .filter(row => row.id && row.name) // L·ªçc b·ªè d√≤ng tr·ªëng
      .map(row => this.formatProductData(row))
      .filter(product => product.status === 'active'); // Ch·ªâ l·∫•y s·∫£n ph·∫©m active
  }

  /**
   * Parse sheet Categories
   * @param {Object} workbook - XLSX workbook object
   * @returns {Array} - M·∫£ng danh m·ª•c ƒë√£ ƒë∆∞·ª£c format
   */
  parseCategoriesSheet(workbook) {
    const sheetName = 'Categories';
    const worksheet = workbook.Sheets[sheetName];
    
    if (!worksheet) {
      console.warn('Sheet Categories kh√¥ng t·ªìn t·∫°i, s·ª≠ d·ª•ng danh m·ª•c m·∫∑c ƒë·ªãnh');
      return this.getDefaultCategories();
    }

    const rawData = XLSX.utils.sheet_to_json(worksheet, { 
      defval: "",
      raw: false
    });

    if (rawData.length === 0) {
      return this.getDefaultCategories();
    }

    console.log('üìÇ ƒê√£ ƒë·ªçc', rawData.length, 'danh m·ª•c t·ª´ sheet Categories');

    return rawData
      .filter(row => row.id && row.name)
      .map(row => this.formatCategoryData(row))
      .filter(category => category.is_active);
  }

  /**
   * Format d·ªØ li·ªáu s·∫£n ph·∫©m t·ª´ Excel row
   * @param {Object} row - D·ªØ li·ªáu d√≤ng t·ª´ Excel
   * @returns {Object} - Object s·∫£n ph·∫©m ƒë√£ format
   */
  formatProductData(row) {
    return {
      id: parseInt(row.id) || 0,
      name: row.name || '',
      description: row.description || '',
      category: row.category || '',
      subcategory: row.subcategory || '',
      
      // Gi√° c·∫£
      price: this.formatPrice(row.price),
      originalPrice: this.formatPrice(row.original_price || row.price),
      discount: parseInt(row.discount_percent) || 0,
      
      // Th√¥ng tin c∆° b·∫£n
      unit: row.unit || 'chai',
      packageSize: row.package_size || '',
      targetAnimal: row.target_animal || '',
      
      // Th√¥ng tin chi ti·∫øt
      fullDescription: row.full_description || row.description,
      functions: row.functions ? row.functions.split(';').map(f => f.trim()) : [],
      usageInstructions: row.usage_instructions || '',
      activeIngredients: row.active_ingredients || '',
      dosage: row.dosage || '',
      withdrawalTime: row.withdrawal_time || '',
      storageConditions: row.storage_conditions || '',
      shelfLife: row.shelf_life || '',
      
      // Th√¥ng tin nh√† s·∫£n xu·∫•t
      manufacturer: row.manufacturer || 'HALIFE Vi·ªát Nh·∫≠t',
      originCountry: row.origin_country || 'Vi·ªát Nam',
      registrationNumber: row.registration_number || '',
      
      // Tr·∫°ng th√°i v√† ƒë√°nh gi√°
      isFeatured: this.parseBoolean(row.is_featured),
      inStock: this.parseBoolean(row.in_stock),
      stockQuantity: parseInt(row.stock_quantity) || 0,
      rating: parseFloat(row.rating) || 0,
      reviewCount: parseInt(row.review_count) || 0,
      
      // H√¨nh ·∫£nh
      image: row.image_url || this.getDefaultProductImage(row.category),
      images: this.parseProductImages(row.image_url, row.gallery_images, row.category),
      
      // SEO
      tags: row.tags ? row.tags.split(',').map(tag => tag.trim()) : [],
      seoKeywords: row.seo_keywords ? row.seo_keywords.split(',').map(k => k.trim()) : [],
      metaDescription: row.meta_description || '',
      
      // Timestamps
      createdDate: row.created_date || new Date().toISOString().split('T')[0],
      updatedDate: row.updated_date || new Date().toISOString().split('T')[0],
      status: row.status || 'active'
    };
  }

  parseProductImages(mainImage, galleryImages, category) {
    const images = [];
    
    // Th√™m h√¨nh ch√≠nh
    if (mainImage && mainImage.trim()) {
      images.push(mainImage.trim());
    }
    
    // Th√™m gallery images
    if (galleryImages && galleryImages.trim()) {
      const galleryUrls = galleryImages.split(';')
        .map(url => url.trim())
        .filter(url => url && url !== mainImage); // Lo·∫°i b·ªè tr√πng l·∫∑p
      images.push(...galleryUrls);
    }
    
    // N·∫øu kh√¥ng c√≥ h√¨nh n√†o, d√πng default
    if (images.length === 0) {
      images.push(this.getDefaultProductImage(category));
    }
    
    return images;
  }

  /**
   * Format d·ªØ li·ªáu danh m·ª•c t·ª´ Excel row
   * @param {Object} row - D·ªØ li·ªáu d√≤ng t·ª´ Excel
   * @returns {Object} - Object danh m·ª•c ƒë√£ format
   */
  formatCategoryData(row) {
    return {
      id: parseInt(row.id) || 0,
      name: row.name || '',
      slug: row.slug || '',
      description: row.description || '',
      icon: row.icon || 'fas fa-box',
      parentId: parseInt(row.parent_id) || null,
      sortOrder: parseInt(row.sort_order) || 999,
      is_active: this.parseBoolean(row.is_active)
    };
  }

  /**
   * Format gi√° ti·ªÅn t·ª´ Excel
   * @param {string|number} value - Gi√° tr·ªã gi√° ti·ªÅn
   * @returns {string} - Gi√° ƒë√£ format
   */
  formatPrice(value) {
    if (!value) return "0";
    
    // N·∫øu ƒë√£ l√† string c√≥ d·∫•u ph·∫©y, gi·ªØ nguy√™n
    if (typeof value === 'string' && value.includes(',')) {
      return value;
    }
    
    // Convert number th√†nh string v·ªõi d·∫•u ph·∫©y
    const numericValue = parseInt(value.toString().replace(/[^\d]/g, '')) || 0;
    return new Intl.NumberFormat('vi-VN').format(numericValue);
  }

  /**
   * Parse boolean t·ª´ Excel
   * @param {string|boolean} value - Gi√° tr·ªã boolean
   * @returns {boolean} - Boolean value
   */
  parseBoolean(value) {
    if (typeof value === 'boolean') return value;
    if (typeof value === 'string') {
      const lowerValue = value.toLowerCase();
      return ['true', '1', 'yes', 'c√≥', 'TRUE', 'YES'].includes(lowerValue);
    }
    return Boolean(value);
  }

  /**
   * L·∫•y h√¨nh ·∫£nh m·∫∑c ƒë·ªãnh cho s·∫£n ph·∫©m theo danh m·ª•c
   * @param {string} category - T√™n danh m·ª•c
   * @returns {string} - URL h√¨nh ·∫£nh m·∫∑c ƒë·ªãnh
   */
  getDefaultProductImage(category) {
    const defaultImages = {
      'Thu·ªëc kh√°ng sinh': 'https://images.unsplash.com/photo-1576671081837-49000212a370?w=400&h=400&fit=crop',
      'Vitamin & kho√°ng ch·∫•t': 'https://images.unsplash.com/photo-1559757148-5c350d0d3c56?w=400&h=400&fit=crop',
      'Th·ª©c ƒÉn b·ªï sung': 'https://images.unsplash.com/photo-1585435557343-3b092031d4cc?w=400&h=400&fit=crop',
      'Th·∫£o d∆∞·ª£c': 'https://images.unsplash.com/photo-1551698618-1dfe5d97d256?w=400&h=400&fit=crop',
      'B·ªô s·∫£n ph·∫©m': 'https://images.unsplash.com/photo-1628009368231-7bb7cfcb55bb?w=400&h=400&fit=crop'
    };

    return defaultImages[category] || 'https://images.unsplash.com/photo-1576671081837-49000212a370?w=400&h=400&fit=crop';
  }

  /**
   * L·∫•y danh m·ª•c m·∫∑c ƒë·ªãnh n·∫øu sheet Categories kh√¥ng c√≥
   * @returns {Array} - M·∫£ng danh m·ª•c m·∫∑c ƒë·ªãnh
   */
  getDefaultCategories() {
    return [
      { id: 1, name: 'Thu·ªëc kh√°ng sinh', icon: 'fas fa-pills', is_active: true },
      { id: 2, name: 'Vitamin & kho√°ng ch·∫•t', icon: 'fas fa-prescription-bottle', is_active: true },
      { id: 3, name: 'Th·ª©c ƒÉn b·ªï sung', icon: 'fas fa-leaf', is_active: true },
      { id: 4, name: 'Th·∫£o d∆∞·ª£c', icon: 'fas fa-seedling', is_active: true },
      { id: 5, name: 'B·ªô s·∫£n ph·∫©m', icon: 'fas fa-box-open', is_active: true }
    ];
  }

  /**
   * Parse metadata t·ª´ workbook
   * @param {Object} workbook - XLSX workbook object
   * @returns {Object} - Metadata object
   */
  parseMetadata(workbook) {
    return {
      sheets: Object.keys(workbook.Sheets),
      lastModified: new Date(),
      version: '1.0',
      source: 'HALIFE Excel Catalog'
    };
  }

  /**
   * L·∫•y s·∫£n ph·∫©m theo danh m·ª•c
   * @param {string} category - T√™n danh m·ª•c
   * @returns {Array} - M·∫£ng s·∫£n ph·∫©m
   */
  getProductsByCategory(category) {
    if (category === 'T·∫•t c·∫£') {
      return this.products.filter(product => product.inStock);
    }
    return this.products.filter(product => 
      product.category === category && product.inStock
    );
  }

  /**
   * T√¨m ki·∫øm s·∫£n ph·∫©m
   * @param {string} query - T·ª´ kh√≥a t√¨m ki·∫øm
   * @returns {Array} - M·∫£ng s·∫£n ph·∫©m k·∫øt qu·∫£
   */
  searchProducts(query) {
    const searchTerm = query.toLowerCase();
    return this.products.filter(product => 
      product.inStock && (
        product.name.toLowerCase().includes(searchTerm) ||
        product.description.toLowerCase().includes(searchTerm) ||
        product.category.toLowerCase().includes(searchTerm) ||
        (product.tags && product.tags.some(tag => tag.toLowerCase().includes(searchTerm)))
      )
    );
  }

  /**
   * L·∫•y s·∫£n ph·∫©m n·ªïi b·∫≠t
   * @returns {Array} - M·∫£ng s·∫£n ph·∫©m n·ªïi b·∫≠t
   */
  getFeaturedProducts() {
    return this.products.filter(product => 
      product.isFeatured && product.inStock
    );
  }

  /**
   * L·∫•y s·∫£n ph·∫©m theo ID
   * @param {number} id - ID s·∫£n ph·∫©m
   * @returns {Object|null} - S·∫£n ph·∫©m ho·∫∑c null
   */
  getProductById(id) {
    return this.products.find(product => product.id === parseInt(id)) || null;
  }

  /**
   * L·∫•y tr·∫°ng th√°i
   * @returns {Object} - Object ch·ª©a tr·∫°ng th√°i
   */
  getStatus() {
    return {
      isLoaded: this.isLoaded,
      error: this.error,
      lastUpdated: this.lastUpdated,
      productCount: this.products.length,
      categoryCount: this.categories.length
    };
  }
}

// Export singleton instance
const excelReader = new ExcelReader();
export default excelReader;